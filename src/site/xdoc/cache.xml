<?xml version="1.0" encoding="UTF-8"?>
<document>
	<properties>
		<title>Cache</title>
		<author email="francois-xavier.bonnet@centraliens.net">Francois-Xavier Bonnet</author>
	</properties>
	<body>
		<h1>Cache</h1>
		<section name="Configuration">
			<p>
				ESIGate uses the
				<a
					href="http://hc.apache.org/httpcomponents-client-ga/httpclient-cache/index.html">HttpClient Cache</a>
				Apache HttpClient since version 4.1. This cache is compliant with
				<a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP/1.1 specification</a>
				The cache can use several alternatives as
				storage, in addition to its
				native backend where cache entries are
				kept in memory there are 2
				other implementations with
				<a href="http://ehcache.org/">EhCache</a>
				and
				<a href="http://memcached.org/">MemCached</a>
				All the parameters for the cache including the choice of the backend
				are set in the main configuration file described in the
				<a href="configuration.html">configuration</a>
				section.
			</p>
		</section>
		<section name="Content expiration, heuristic expiration, forced expiration">
			<p>By default the cache uses Cache-control and
				Expires headers to
				check if a response is cacheable and how long.
			</p>
			<p>If
				the headers contains only a Last-modified header with no other
				header
				to define when the response expires, the cache will keep the
				response
				a for a duration that will be a fraction of its age, by
				default 10%.
				This mechanism is known as "Heuristic expiration" and is
				well
				described in HTTP 1.1 specification.
			</p>
			<p>In certain cases you may want to force the time-to-live of all the
				responses coming from a server regardless of the http headers
				presents in the responses. This can be done using the parameter
				"ttl" in the configuration.
			</p>
		</section>
		<section name="Variants, E-tag and Vary headers">
			<p>The cache will store several response variants
				depending on
				E-tag
				and Vary headers. This strategy can be very
				effective when some
				contents depend on the user profile or language.
			</p>
		</section>
		<section name="Cache revalidation">
			<p>When a server response contains E-tag and/or
				Last-modified header, the
				cache will use conditional requests using
				If-none-match and/or
				If-modified-since request headers
				for subsequent
				request to revalidate
				the cache entries without having
				to reload them
				each time.
			</p>
		</section>
		<section name="Background revalidation">
			<p>
				The cache also implements the
				<a href="http://tools.ietf.org/html/rfc5861">HTTP Cache-Control Extensions for Stale Content</a>
				specification. This means that the cache receives a request and
				already has a response to be faster and then revalidate it in order
				to have an up-to-date response next time. It can also use the stale
				cache entry when the target server is not responding.
			</p>
			<p>According to the specification, this behavior depends only on the
				headers Stale-while-revalidate and Stale-if-error defined by the
				target server, but in EsiGate you can also set these parameters by
				default for all cacheable responses.</p>
		</section>
	</body>
</document>